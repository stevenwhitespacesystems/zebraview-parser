# Agent Implementation Workflow Template

This template defines the complete agent workflow for implementing a ZPL command feature. Each task specifies the agent type, input context, commands to run, outputs to generate, and state to update.

---

## Feature Context Loading

### Required Inputs
- **PRP File**: `features/[feature-id]/PRP.md` - Feature definition and specifications  
- **Research Findings**: `features/[feature-id]/agents/zpl-command-researcher/findings.md` - Technical analysis
- **Project Standards**: `CLAUDE.md` - Build commands and architecture patterns

### State Management
**State File**: `features/[feature-id]/agents/state.yaml`
```yaml
# Single source of truth for feature progress
feature_id: [feature-id]
command: [COMMAND]
phase: implementation  # research|prp|implementation
status: active         # active|complete|failed

implementation:
  status: active       # pending|active|complete|failed
  iteration: 0         # Current validation loop iteration
  max_iterations: 15
  last_failure: none   # tests|coverage|detekt|ktlint|performance|integration|demo
```

All agents must update state using: `yq w -i state.yaml [field] [value]`

---

## Agent Workflow Phases

### Phase 1: Test Creation (RED Phase)

#### Task 1.1: Create Test File
**Agent**: @kotlin-senior-dev  
**Execution**: [S] Sequential  
**Input Context**:
- Load: `features/[feature-id]/PRP.md` (sections 2, 5)
- Focus: Command specification and test scenarios
- Reference: Existing test patterns in `src/test/kotlin/.../parser/`

**Commands**:
```bash
# Read PRP for test specifications
cat features/[feature-id]/PRP.md

# Check existing test patterns
ls src/test/kotlin/com/whitespacesystems/parser/parser/*Test.kt
```

**Implementation**: Create `src/test/kotlin/.../parser/[CommandName]Test.kt`
**Output**: `features/[feature-id]/agents/phase-1/tests-created.md`
**State Update**: `yq w -i state.yaml implementation.phase-1.tests "created"`

**Output Format**:
```markdown
## Tests Created - [CommandName]
- [x] Test file created: [CommandName]Test.kt  
- [x] Basic functionality tests (X tests)
- [x] Edge case tests (Y tests)  
- [x] Error scenario tests (Z tests)
- [x] Integration tests (if applicable)

### Test Coverage Plan
- Minimal command parsing: `^[COMMAND]`
- Full parameter parsing: `^[COMMAND][params]`
- Field data handling: (if applicable)
- Error conditions: Invalid params, malformed syntax
```

#### Task 1.2: Confirm RED Phase
**Agent**: @test-runner  
**Execution**: [S] Sequential  
**Input Context**:
- Previous: `phase-1/tests-created.md`
- Command: `./gradlew test --tests "*[CommandName]Test"`

**Commands**:
```bash
# Run the newly created tests (should all fail)
./gradlew test --tests "*[CommandName]Test"

# Update state with RED confirmation
yq w -i state.yaml implementation.phase-1.red "confirmed"
```

**Output**: `features/[feature-id]/agents/phase-1/red-confirmation.md`
**State Update**: `yq w -i state.yaml implementation.phase-1.status "complete"`

**Output Format**:
```markdown
## RED Phase Confirmation
- [x] All tests failing as expected
- Total tests: X
- All failing: ✓  
- Ready for GREEN phase: ✓
```

### Phase 2: Initial Implementation

#### Task 2.1: Create AST Node
**Agent**: @kotlin-senior-dev  
**Execution**: [P] Parallel (with 2.2, 2.3)  
**Input Context**:
- Load: `features/[feature-id]/PRP.md` (section 4 - AST Node Structure)
- Reference: Similar commands in `src/main/kotlin/.../ast/`
- Check: Visitor pattern implementation

**Commands**:
```bash
# Read PRP design specifications
cat features/[feature-id]/PRP.md

# Check existing AST patterns
ls src/main/kotlin/com/whitespacesystems/parser/ast/*Command.kt
```

**Implementation**: Create `src/main/kotlin/.../ast/[CommandName]Command.kt`
**Output**: `features/[feature-id]/agents/phase-2/ast-node.md`
**State Update**: `yq w -i state.yaml implementation.phase-2.ast-node "created"`

#### Task 2.2: Update Visitor Interface
**Agent**: @kotlin-senior-dev  
**Execution**: [P] Parallel (with 2.1, 2.3)  
**Input Context**:
- Previous: `phase-2/ast-node.md` (for method signature)
- Reference: `src/main/kotlin/.../ast/ZplNodeVisitor.kt`

**Commands**:
```bash
# Check current visitor interface
cat src/main/kotlin/com/whitespacesystems/parser/ast/ZplNodeVisitor.kt

# Update with new visit method
# yq commands will track this in state
yq w -i state.yaml implementation.phase-2.visitor-interface "updated"
```

**Implementation**: Add `fun visit([commandName]: [CommandName]Command): T` to ZplNodeVisitor.kt
**Output**: `features/[feature-id]/agents/phase-2/visitor-interface.md`
**State Update**: `yq w -i state.yaml implementation.phase-2.visitor-interface "updated"`

#### Task 2.3: Implement Visitor
**Agent**: @kotlin-senior-dev  
**Execution**: [P] Parallel (with 2.1, 2.2)  
**Input Context**:
- Previous: `phase-2/ast-node.md` and `phase-2/visitor-interface.md`
- Reference: `src/main/kotlin/.../utils/AstPrinterVisitorImpl.kt`

**Commands**:
```bash
# Check current visitor implementation patterns
cat src/main/kotlin/com/whitespacesystems/parser/utils/AstPrinterVisitorImpl.kt | grep -A5 "override fun visit"
```

**Implementation**: Add visitor implementation to AstPrinterVisitorImpl.kt
**Output**: `features/[feature-id]/agents/phase-2/visitor-impl.md`
**State Update**: `yq w -i state.yaml implementation.phase-2.visitor-impl "implemented"`

#### Task 2.4: Add Parser Method
**Agent**: @kotlin-senior-dev  
**Execution**: [S] Sequential (after 2.1-2.3)  
**Input Context**:
- Load: `features/[feature-id]/PRP.md` (section 4 - Parser Integration)
- Previous: All phase-2 parallel tasks
- Reference: `src/main/kotlin/.../parser/ZplParser.kt`

**Commands**:
```bash
# Check parser patterns for similar commands
cat src/main/kotlin/com/whitespacesystems/parser/parser/ZplParser.kt | grep -A10 "private fun parse"

# Verify command info structure
cat src/main/kotlin/com/whitespacesystems/parser/lexer/Lexer.kt | grep -A5 "commandInfo"
```

**Implementation**: Add `parse[CommandName]()` method and integrate into main parser switch
**Output**: `features/[feature-id]/agents/phase-2/parser-method.md`
**State Update**: `yq w -i state.yaml implementation.phase-2.parser-method "added"`

#### Task 2.5: Update Lexer
**Agent**: @kotlin-senior-dev  
**Execution**: [S] Sequential (after 2.4)  
**Input Context**:
- Load: `features/[feature-id]/PRP.md` (section 2 - Command Specification)  
- Previous: `phase-2/parser-method.md`
- Reference: `src/main/kotlin/.../lexer/Lexer.kt` commandInfo map

**Commands**:
```bash
# Check current commandInfo structure
cat src/main/kotlin/com/whitespacesystems/parser/lexer/Lexer.kt | grep -A20 "val commandInfo"
```

**Implementation**: Add command to commandInfo map in Lexer.kt
**Output**: `features/[feature-id]/agents/phase-2/lexer-update.md`
**State Update**: `yq w -i state.yaml implementation.phase-2.lexer "updated"`

#### Task 2.6: Create Utilities (Conditional)
**Agent**: @kotlin-senior-dev  
**Execution**: [S] Sequential (if needed)  
**Input Context**:
- Load: `features/[feature-id]/PRP.md` (section 4 - Utility Functions)
- Condition: Skip if no complex parsing needed
- Reference: `src/main/kotlin/.../parser/*ParsingUtils.kt`

**Commands**:
```bash
# Check if utilities are needed from PRP
grep -i "utility\|complex" features/[feature-id]/PRP.md

# Check existing utilities
ls src/main/kotlin/com/whitespacesystems/parser/parser/*Utils.kt
```

**Implementation**: Create `[CommandName]ParsingUtils.kt` (if required)
**Output**: `features/[feature-id]/agents/phase-2/utilities.md`
**State Update**: `yq w -i state.yaml implementation.phase-2.utilities "created"` (or "skipped")

### Phase 3: Validation & Fix Loop

#### Loop State Management
All validation tasks use shared loop state tracking:
```bash
# Update iteration count
yq w -i state.yaml implementation.iteration $(($(yq r state.yaml implementation.iteration) + 1))

# Track failure type  
yq w -i state.yaml implementation.last_failure "[failure-type]"  # tests|coverage|detekt|ktlint|performance|integration|demo

# Check loop limits
ITERATION=$(yq r state.yaml implementation.iteration)
MAX_ITER=$(yq r state.yaml implementation.max_iterations)
if [ $ITERATION -gt $MAX_ITER ]; then
  echo "ESCALATION: Maximum iterations exceeded"
  exit 1
fi
```

#### Task 3.1: Run Tests
**Agent**: @test-runner  
**Execution**: [S] Sequential (Loop Entry Point)  
**Input Context**:
- Previous: All phase-2 outputs
- Command: `./gradlew test --tests "*[CommandName]Test"`

**Commands**:
```bash
# Run tests for this command
./gradlew test --tests "*[CommandName]Test"

# Check test results and update state
if [ $? -eq 0 ]; then
  yq w -i state.yaml implementation.tests "passing"
  # Continue to coverage
else
  yq w -i state.yaml implementation.last_failure "tests"
  # Go to FIX-3.1
fi
```

**Output**: `features/[feature-id]/agents/validation/test-results.md`
**State Update**: `yq w -i state.yaml implementation.tests "[passing|failing]"`

**Loop Control**: 
- Success (100% pass): → Continue to 3.2
- Failure: → Go to FIX-3.1

#### FIX-3.1: Fix Test Failures
**Agent**: @kotlin-senior-dev  
**Execution**: [S] Sequential (Fix Task)  
**Input Context**:
- Load: `validation/test-results.md` (failure details)
- Reference: Implementation files created in phase-2
- Loop: Update iteration count before starting

**Commands**:
```bash
# Update iteration counter
yq w -i state.yaml implementation.iteration $(($(yq r state.yaml implementation.iteration) + 1))

# Read test failure details
cat features/[feature-id]/agents/validation/test-results.md
```

**Implementation**: Fix failing tests based on error analysis
**Output**: `features/[feature-id]/agents/validation/test-fixes-iteration-[N].md`
**State Update**: `yq w -i state.yaml implementation.last_failure "tests"`
**Loop Control**: → Return to 3.1

**Output Format**:
```markdown
## Test Failures Fixed - Iteration [N]
Loop Count: [N]/15

### Failures Addressed
- [x] Test: "should parse minimal [COMMAND] command" 
  - Reason: Expected [CommandName]Command but got null
  - Fix: Added [COMMAND] to parser switch statement
  - Fixed in: ZplParser.kt line [X]

- [x] Test: "should handle field data"
  - Reason: NullPointerException on field data parsing
  - Fix: Added null check in parse[CommandName]() method
  - Fixed in: ZplParser.kt line [Y]
```

#### Task 3.2: Check Coverage
**Agent**: @coverage-runner  
**Execution**: [S] Sequential (after tests pass)  
**Input Context**:
- Prerequisite: Tests passing from 3.1
- Command: `./gradlew jacocoTestReport`

**Commands**:
```bash
# Generate coverage report
./gradlew jacocoTestReport

# Check coverage percentage for new code
# Coverage report location: build/jacocoHtml/index.html
```

**Output**: `features/[feature-id]/agents/validation/coverage.md`
**State Update**: `yq w -i state.yaml implementation.coverage "[percentage]"`

**Loop Control**: 
- Success (≥80%): → Continue to 3.3
- Failure: → Go to FIX-3.2

#### FIX-3.2: Add Missing Coverage
**Agent**: @kotlin-senior-dev  
**Execution**: [S] Sequential (Fix Task)  
**Input Context**:
- Load: `validation/coverage.md` (uncovered lines)
- Target: Achieve ≥80% coverage

**Commands**:
```bash
# Update iteration counter
yq w -i state.yaml implementation.iteration $(($(yq r state.yaml implementation.iteration) + 1))

# Read coverage gaps
cat features/[feature-id]/agents/validation/coverage.md
```

**Implementation**: Add tests for uncovered code paths
**Output**: `features/[feature-id]/agents/validation/coverage-fixes-iteration-[N].md`
**State Update**: `yq w -i state.yaml implementation.last_failure "coverage"`
**Loop Control**: → Return to 3.1 (rerun all tests)

#### Task 3.3: Static Analysis
**Agent**: @static-analysis-runner  
**Execution**: [P] Parallel (with 3.4, after coverage passes)  
**Input Context**:
- Prerequisite: Tests and coverage passing
- Command: `./gradlew detekt`

**Commands**:
```bash
# Run static analysis
./gradlew detekt

# Check for violations
if [ $? -eq 0 ]; then
  yq w -i state.yaml implementation.detekt "clean"
else
  yq w -i state.yaml implementation.last_failure "detekt"
fi
```

**Output**: `features/[feature-id]/agents/validation/detekt.md`
**State Update**: `yq w -i state.yaml implementation.detekt "[clean|violations]"`

**Loop Control**: 
- Success (zero violations): → Continue to 3.5
- Failure: → Go to FIX-3.3

#### FIX-3.3: Fix Static Analysis
**Agent**: @kotlin-senior-dev  
**Execution**: [S] Sequential (Fix Task)  
**Input Context**:
- Load: `validation/detekt.md` (violation details)
- Rule: NEVER suppress, always fix

**Commands**:
```bash
# Update iteration counter
yq w -i state.yaml implementation.iteration $(($(yq r state.yaml implementation.iteration) + 1))

# Read detekt violations
cat features/[feature-id]/agents/validation/detekt.md
```

**Implementation**: Fix all detekt violations without suppression
**Output**: `features/[feature-id]/agents/validation/detekt-fixes-iteration-[N].md`
**State Update**: `yq w -i state.yaml implementation.last_failure "detekt"`
**Loop Control**: → Return to 3.3

#### Task 3.4: Linting
**Agent**: @linting-runner  
**Execution**: [P] Parallel (with 3.3, after coverage passes)  
**Input Context**:
- Prerequisite: Tests and coverage passing
- Commands: `./gradlew ktlintFormat` then `./gradlew ktlintCheck`

**Commands**:
```bash
# Auto-fix formatting
./gradlew ktlintFormat

# Check for remaining violations
./gradlew ktlintCheck

if [ $? -eq 0 ]; then
  yq w -i state.yaml implementation.ktlint "clean"
else
  yq w -i state.yaml implementation.last_failure "ktlint"
fi
```

**Output**: `features/[feature-id]/agents/validation/linting.md`
**State Update**: `yq w -i state.yaml implementation.ktlint "[clean|violations]"`

**Loop Control**: 
- Success (zero violations): → Continue to 3.5
- Failure: → Go to FIX-3.4

#### FIX-3.4: Fix Linting
**Agent**: @kotlin-senior-dev  
**Execution**: [S] Sequential (Fix Task)  
**Input Context**:
- Load: `validation/linting.md` (linting issues)

**Commands**:
```bash
# Update iteration counter  
yq w -i state.yaml implementation.iteration $(($(yq r state.yaml implementation.iteration) + 1))

# Read linting violations
cat features/[feature-id]/agents/validation/linting.md
```

**Implementation**: Fix all ktlint violations
**Output**: `features/[feature-id]/agents/validation/linting-fixes-iteration-[N].md`
**State Update**: `yq w -i state.yaml implementation.last_failure "ktlint"`
**Loop Control**: → Return to 3.4

#### Task 3.5: Create Benchmarks (Conditional)
**Agent**: @kotlin-senior-dev  
**Execution**: [S] Sequential (if Complex command)  
**Input Context**:
- Load: `features/[feature-id]/PRP.md` (complexity rating)
- Condition: Skip if Simple command OR benchmarks exist
- Reference: `src/benchmark/kotlin/.../`

**Commands**:
```bash
# Check if benchmarks needed
COMPLEXITY=$(grep "Complexity:" features/[feature-id]/PRP.md | cut -d: -f2)
if [[ $COMPLEXITY == *"Complex"* ]]; then
  # Create benchmark
  echo "Creating benchmark for complex command"
else
  yq w -i state.yaml implementation.benchmarks "skipped"
  # Skip to 3.7
fi
```

**Implementation**: Create `src/benchmark/kotlin/.../[CommandName]Benchmarks.kt` (if needed)
**Output**: `features/[feature-id]/agents/validation/benchmark-created.md`
**State Update**: `yq w -i state.yaml implementation.benchmarks "[created|skipped]"`

#### Task 3.6: Performance Check
**Agent**: @benchmark-runner  
**Execution**: [S] Sequential (if benchmarks exist)  
**Input Context**:
- Prerequisite: Benchmarks created in 3.5
- Command: `./gradlew benchmark`

**Commands**:
```bash
# Run benchmarks
./gradlew benchmark

# Check for performance regressions
if [ $? -eq 0 ]; then
  yq w -i state.yaml implementation.performance "acceptable"
else
  yq w -i state.yaml implementation.last_failure "performance"
fi
```

**Output**: `features/[feature-id]/agents/validation/performance.md`
**State Update**: `yq w -i state.yaml implementation.performance "[acceptable|regression]"`

**Loop Control**: 
- Success (no >10% regression): → Continue to 3.7
- Failure: → Go to FIX-3.6

#### FIX-3.6: Optimize Performance
**Agent**: @kotlin-senior-dev  
**Execution**: [S] Sequential (Fix Task)  
**Input Context**:
- Load: `validation/performance.md` (performance metrics)

**Commands**:
```bash
# Update iteration counter
yq w -i state.yaml implementation.iteration $(($(yq r state.yaml implementation.iteration) + 1))

# Read performance issues
cat features/[feature-id]/agents/validation/performance.md
```

**Implementation**: Optimize code for performance requirements
**Output**: `features/[feature-id]/agents/validation/performance-fixes-iteration-[N].md`
**State Update**: `yq w -i state.yaml implementation.last_failure "performance"`
**Loop Control**: → Return to 3.1 (ensure optimization didn't break tests)

#### Task 3.7: Integration Test
**Agent**: @test-runner  
**Execution**: [S] Sequential (after all quality checks pass)  
**Input Context**:
- Prerequisite: All validation tasks passing
- Command: `./gradlew check`

**Commands**:
```bash
# Run full integration test
./gradlew check

if [ $? -eq 0 ]; then
  yq w -i state.yaml implementation.integration "success"
else
  yq w -i state.yaml implementation.last_failure "integration"
fi
```

**Output**: `features/[feature-id]/agents/validation/integration.md`
**State Update**: `yq w -i state.yaml implementation.integration "[success|failure]"`

**Loop Control**: 
- Success (BUILD SUCCESSFUL): → Continue to 3.8
- Failure: → Analyze specific failure and fix

#### Task 3.8: Demo Validation  
**Agent**: @test-runner  
**Execution**: [S] Sequential (final validation)  
**Input Context**:
- Prerequisite: Integration tests passing
- Command: `./gradlew run`

**Commands**:
```bash
# Run demo application
./gradlew run

if [ $? -eq 0 ]; then
  yq w -i state.yaml implementation.demo "success"
  yq w -i state.yaml status "complete"
  yq w -i state.yaml phase "complete"
else
  yq w -i state.yaml implementation.last_failure "demo"
fi
```

**Output**: `features/[feature-id]/agents/validation/demo.md`
**State Update**: `yq w -i state.yaml implementation.demo "[success|failure]"`

**Loop Control**: 
- Success: → FEATURE COMPLETE
- Failure: → Go to FIX-3.8

#### FIX-3.8: Fix Runtime Issues
**Agent**: @kotlin-senior-dev  
**Execution**: [S] Sequential (Fix Task)  
**Input Context**:
- Load: `validation/demo.md` (runtime error details)

**Commands**:
```bash
# Update iteration counter
yq w -i state.yaml implementation.iteration $(($(yq r state.yaml implementation.iteration) + 1))

# Read demo failure details
cat features/[feature-id]/agents/validation/demo.md
```

**Implementation**: Fix runtime issues preventing demo execution
**Output**: `features/[feature-id]/agents/validation/demo-fixes-iteration-[N].md`
**State Update**: `yq w -i state.yaml implementation.last_failure "demo"`
**Loop Control**: → Return to 3.1

---

## Progress Tracking

### State Monitoring Commands
```bash
# Check current progress
echo "Phase: $(yq r state.yaml phase)"
echo "Status: $(yq r state.yaml status)" 
echo "Iteration: $(yq r state.yaml implementation.iteration)/$(yq r state.yaml implementation.max_iterations)"
echo "Last failure: $(yq r state.yaml implementation.last_failure)"

# Quick status check
PHASE=$(yq r state.yaml phase)
STATUS=$(yq r state.yaml status)
echo "[$PHASE] $STATUS"

# Check specific validation status
echo "Tests: $(yq r state.yaml implementation.tests)"
echo "Coverage: $(yq r state.yaml implementation.coverage)"
echo "Detekt: $(yq r state.yaml implementation.detekt)"
echo "Ktlint: $(yq r state.yaml implementation.ktlint)"
```

### Loop Control Logic
```yaml
LOOP_START: Task 3.1
LOOP_CONDITION: Any validation task fails
LOOP_MAX_ITERATIONS: 15
ABORT_CONDITION: iteration > max_iterations
SUCCESS_CONDITION: All validation tasks pass
```

---

## Recovery & Escalation

### Intelligent Failure Handling
- **Iterations 1-5**: Focus on implementation fixes
- **Iterations 6-10**: Check test correctness and requirements
- **Iterations 11-15**: Consider architectural changes and escalate

### Circular Fix Detection
If same failure type occurs 3+ times:
- Flag as potential design issue
- Try alternative implementation approach  
- Document pattern for human review

### Escalation Conditions
**STOP and escalate if**:
- Iteration count exceeds 15
- Research findings conflict with codebase reality
- Circular dependency detected between fixes
- Performance requirement appears impossible
- Test expectations seem incorrect (not implementation)
- Architecture change required (new base classes, etc.)

**Escalation Output**: `features/[feature-id]/agents/ESCALATION.md`
**Include**: Full state.yaml, last 5 iterations, specific blocker

### Agent Type Reference
- **@kotlin-senior-dev**: File creation, implementation, code modifications
- **@test-runner**: Running tests, validation, integration checks
- **@linting-runner**: Running ktlint commands
- **@static-analysis-runner**: Running detekt analysis  
- **@coverage-runner**: Running test coverage reports
- **@benchmark-runner**: Running performance benchmarks

---

## Success Criteria

**Feature implementation is COMPLETE when**:
- [x] All tests passing (100%)
- [x] Coverage ≥80%
- [x] Zero linting violations  
- [x] Zero static analysis issues
- [x] No performance regressions >10%
- [x] Demo application runs successfully
- [x] State file shows: `status: complete`
- [x] All quality gates pass: `./gradlew check`